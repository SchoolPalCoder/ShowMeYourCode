# 利用Jest编写测试代码

## 前言

本想打算研究swagger2Mock的实现逻辑,琢磨了下代码之后发现,基本上是从一个格式转化到另一个格式,更多的是业务逻辑上的转换,没有太多的技术知识.不过在研究`swagger-parser-mock`这个功能库时,意外的收获到一些关于单元测试的编写实践.于是做下分享与记录.

## 知识点

### 特性

适应性：Jest是模块化、可扩展和可配置的。也就是说能应付小功能也可以应对大场景下的测试.

快速和沙盒:Jest虚拟化JavaScript环境,能模拟浏览器,并在工作进程之间并行运行测试。

快照测试:Jest能够对React 树进行快照或别的序列化数值快速编写测试,提供快速更新的用户体验。

快速交互模式: 错误信息会有帮助的颜色编码标记,堆栈跟踪快速指向问题的根源。

#### 语法

Jest是Facebook开发的一个对javascript进行单元测试的工具，之前仅在其内部使用，后开源，并且是在Jasmine测试框架上演变开发而来，使用了我们熟知的`expect(value).toBe(other)`这种断言格式。这种格式符合我们的日常口语逻辑:期望某个值是某个值.

举个例子:

```javascript
test('1 + 2 等于 3', ()=> {
    expect(1 + 2).toBe(3);
});
```

上面这段代码很简单,也很没有实用性,别慌!我只是为了引出`test`的使用方法.`test`实际上就是声明一个测试用例,第一个参数为用例的名称,想取啥取啥,不过一定要与测试代码的功能相关,不然执行测试脚本的时候,你就不能直观的看出来是哪段用例报错了.

而在`test`之上,又有叫做`describe`的东西.它是用例的集合,比如一段增删改查的流程就可以放在一个`describe`中,他的使用方法与`test`一致,都是首个参数为名称,第二个参数为测试执行函数.

其实要介绍的基本就这么多,接下来就是结合`easyMock`项目,分析几个具有代表性的例子.

### 案例分析

#### 工具函数的单元测试

```javascript
'use strict'

const util = require('../../util')
describe('test/util/index.test.js', () => {
  test('params', () => {
    let params = util.params('/api/:user/:id', '/api/souche/123')
    expect(params).toEqual({
      user: 'souche',
      id: '123'
    })

    params = util.params('/api/:user/:id', '/api/a%AFc/123')

    expect(params).toEqual({
      user: 'a%AFc',
      id: '123'
    })

    params = util.params('/api/:user/:id', '/api/123')

    expect(params).toEqual({})
  })
  //...
})
```

这段代码是为了测试`util`模块中封装的`params`方法,光看测试代码的编写,应该就能猜的出这个方法是用来干嘛的,没错!他主要是能根据一个格式化Url和一个实际Url生成实际url所表明的参数对象,而上面三段断言语句分别解决不同实际url的场景下,`params`能否返回期望的值.

从中可以学习到的就是对于工具型的函数,单元测试要尽可能的覆盖不同场景.每个场景一个测试用例,做到本方法的最大覆盖率.

结合一下开发中的应用场景,假设我们项目中用到如下一个对于数值的操作函数:

```javascript
// test1.js
/**
 * 格式化数字默认保留1位小数，重点是如果最后是0则清掉
 * @param    {[type]}                 num 你的数字
 * @param    {Number}                 len 某认为1，想保留几个就保留几个
 * @return   {[type]}                     [description]
 *
 * @Author   zy
 * @DateTime 2017-11-03T18:24:59+0800
 */
let numToFixed = (num, len = 1) => {

    if (Math.floor(num) == num) {
        return num
    }
    return parseFloat(num.toFixed(len).replace(/0+$/, ''));
}
export {numToFixed}
```

结合下尽可能出现的场景,试着写下单元测试:

```js
import {numToFixed} from '../test1'

describe('numToFixed', () => {
  test('参数为整数', () => {
    let res = numToFixed(2)
    expect(res).toBe(2)
  })
  test('参数为两位小数', () => {
    let res = numToFixed(2.16)
    expect(res).toBe(2.2)
  })
  test('参数为两位小数,保留两位小数', () => {
    let res = numToFixed(2.16, 2)
    expect(res).toBe(2.16)
  })
  test('参数为两位小数,保留两位小数,并且结果的最后一位是零', () => {
    let res = numToFixed(2.101, 2)
    expect(res).toBe(2.1)
  })
  test('参数为两位小数,保留两位小数,并且结果的最后一位会因为进位加一', () => {
    let res = numToFixed(2.107, 2)
    expect(res).toBe(2.11)
  })
})

```
执行`jest`命令,得到如下测试结果:

```shell
➜  controllers git:(master) ✗ jest fixed.test.js
 PASS  ./fixed.test.js

Test Suites: 1 passed, 1 total
Tests:       5 passed, 5 total
Snapshots:   0 total
Time:        0.943s, estimated 1s
Ran all test suites matching /fixed.test.js/i.
```

然后实际开发的时候,有同事发现这个操作函数最后的`replace`方法好像可以去掉,于是去掉代码之后,我们再次跑一遍单元测试命令:

```shell
➜  controllers git:(master) ✗ jest fixed.test.js
 PASS  ./fixed.test.js

Test Suites: 1 passed, 1 total
Tests:       5 passed, 5 total
Snapshots:   0 total
Time:        0.314s, estimated 1s
Ran all test suites matching /fixed.test.js/i.
```

竟然神奇的发现测试的总体时间减少了三分之一,并且全部通过了测试.当然,不排除一些机子运行状态不同导致的时间差别,不过能少写段代码自然是最好的.

#### 接口测试















